#!/bin/bash

git rev-parse --is-inside-work-tree >> /dev/null 2>&1

if [[ ! $? -eq 0 ]]; then
    echo "Not inside a git repo"
    exit
fi

REMOTE_CFG="$(git config lock.remote)"
REMOTE=${REMOTE_CFG:-origin}
BRANCH="git-lock"
BRANCHPATH="refs/heads/${BRANCH}"
BRANCHREMOTE="refs/remotes/${REMOTE}/${BRANCH}"
LOCKFILE="git-lock"
MSG="Update git-lock"
TOPLEVEL="$(realpath "$(git rev-parse --show-toplevel)")"
TOPLEVEL_C="$(echo "$TOPLEVEL" | wc -c)"

ORIG_PWD="$(pwd -P)"
pushd "$TOPLEVEL" >> /dev/null

git_lock_init_local() {
    echo "Creating locking branch..."
    current=$(cat .git/HEAD)
    git checkout --orphan "$BRANCH" >> /dev/null
    git reset
    true > "$LOCKFILE"
    git add "$LOCKFILE" >> /dev/null
    git commit -m "Init git-lock" >> /dev/null
    echo "$current" > .git/HEAD
    git reset
    git clean -f "$LOCKFILE" >> /dev/null
}

git_lock_show() {
    git show "$BRANCH:$LOCKFILE" | cat
}

git_lock_push() {
    git push "$REMOTE" "$BRANCHPATH:$BRANCHPATH" >> /dev/null 2>&1

    if [[ ! $? -eq 0 ]]; then
        echo "Unable to push locking branch to $REMOTE"
        exit
    fi

    echo "Lock updated"
}

git_lock_fetch() {
    git fetch "$REMOTE" "${BRANCH}:${BRANCH}" >> /dev/null
}

git_lock_acquire() {
    path="$1"

    git_lock_fetch

    grep -Fx "${path}" "$WORKTREE/$LOCKFILE" >> /dev/null

    if [[ $? -eq 0 ]]; then
        echo "Lock is held"
        exit
    fi

    echo "$path" >> "$WORKTREE/$LOCKFILE"
}

git fetch >> /dev/null 2>&1

git rev-parse "$BRANCHREMOTE" >> /dev/null 2>&1

if [[ ! $? -eq 0 ]]; then
    git rev-parse "$BRANCHREMOTE" >> /dev/null 2>&1

    if [[ ! $? -eq 0 ]]; then
        git_lock_init_local
    fi

    git_lock_push
fi

git_lock_fetch

# --- git-lock init is assured ---

cmd="$1"
shift

if [[ "$cmd" == "show" ]]; then
    git_lock_show
    exit
fi

TMPDIR="$(mktemp -d)"
trap "rm -rf \"$TMPDIR\"" EXIT

WORKTREE="$TMPDIR/tree"
mkdir -p "$WORKTREE"

if git show-ref --quiet "$BRANCHPATH"; then
    git --work-tree="$WORKTREE" checkout "$BRANCHPATH" -- "$LOCKFILE"
fi

if [[ "$cmd" == "acquire" ]]; then
    to_lock="$1"
    shift

    if [[ -z "$to_lock" ]]; then
        echo "No file path given"
        exit
    fi

    to_lock="$(realpath -P "${ORIG_PWD}/${to_lock}")"
    to_lock="$(echo "$to_lock" | cut -c "$(($TOPLEVEL_C+1))"-)"

    if [[ ! -e "$to_lock" ]]; then
        echo "File does not exist: $to_lock"
        exit
    fi

    git show "HEAD:$to_lock" >> /dev/null 2>&1

    if [[ ! $? -eq 0 ]]; then
        echo "File is not committed to git: $to_lock"
        exit
    fi

    git_lock_acquire "$to_lock"

    blob=$(git hash-object -w "$WORKTREE/$LOCKFILE")

    tree=$(echo "100644 blob $blob	$LOCKFILE" | git mktree)

    parent=$(git rev-parse "$BRANCHPATH")
    commit=$(echo "$MSG" | git commit-tree $tree -p $parent)

    git update-ref "$BRANCHPATH" "$commit"

    git_lock_push
    exit
fi

echo "Updated at $(date)" >> "$WORKTREE/$LOCKFILE"

blob=$(git hash-object -w "$WORKTREE/$LOCKFILE")

tree=$(echo "100644 blob $blob	$LOCKFILE" | git mktree)

parent=$(git rev-parse "$BRANCHPATH")
commit=$(echo "$MSG" | git commit-tree $tree -p $parent)

git update-ref "$BRANCHPATH" "$commit"

git_lock_push
